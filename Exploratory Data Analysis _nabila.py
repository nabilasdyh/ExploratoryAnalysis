# -*- coding: utf-8 -*-
"""Assiggnment EDA_Nabila Sa'diyah.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dFo2pN8VzXRtAEtZrqBRA_e8VBiz8Aew

# 1. Anda bekerja sebagai seorang data scientist, atasan anda mengirimkan anda data kepada anda dan meminta untuk memberikan analisa dengan menggunakan :
- semua metode pada proses Exploratory Data Analysis. Lakukan proses Feature Engineering terlebih dahulu dan mengecek secara teliti pada tiap kolom data sembari melakukan data understanding. **(20 Poin)**
"""

# import library
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# load data
df = pd.read_csv('/content/ecommerce.csv')
data = df.copy()

# data -> for EDA process
# data di-copy dari df supaya dalam proses EDA hanya dilakukan pada 'data' tidak dengan 'df'
data.head()

"""## Data Deskripsi
InvoiceNo : Nomor invoice pembelian barang<br>
StockCode : kode unik yang diberikan pada setiap produk<br>
Description : nama produk (produk yang dibeli)<br>
Quantity  : jumlah/kuantitas produk yang dibeli<br>
InvoiceDate : Tanggal invoice terbit<br>
UnitPrice : harga produk per unit<br>
CustomerID : ID pelanggan<br>
Country : kota pelanggan/pembeli<br>

## Preliminary
"""

# menampilkan 5 sample baris data
data.sample(5)

"""1. kolom invoiceNo, CustomerID, UnitPrice dan Quantity merupakan data numerik; kolom StockCode, Description, dan Country merupakan data kategorik; sedangkan kolom InvoiceDate merupakan data date
2. kolom UnitPrice hanya memberi informasi harga per unit/per produk bukan jumlah harga untuk keseluruhan quantity yang dibeli pelanggan.
3. kolom InvoiceNo adalah nomor unik yang berbeda untuk setiap transaksi.
"""

data.info()

"""1. Data memiliki 8 kolom dan 4870 baris
2. Semua tipe data tampaknya sesuai, mengingat sebelumnya sudah cek sample baris data, kecuali kolom InvoiceDate seharusnya type data date, akan diperbaiki kemudian
3. Tidak terdapat missing value
"""

# mengelompokkan berdasarkan data numerik atau data kategorik
numerik =['InvoiceNo', 'CustomerID', 'Quantity', 'UnitPrice']
kategorik = ['StockCode', 'Description', 'Country'] #InvoiceDate tidak dimasukkan karna seharusnya data date

numerik_kolom = data.select_dtypes(include=['number']).columns
print("Kolom Numerik:")
print(numerik_kolom)

kategorik_kolom = data.select_dtypes(include=['object']).columns
print("Kolom Kategorik:")
print(kategorik_kolom)

data[numerik].describe()

"""1. mengabaikan data InvoiceNo karna InvoiceNo biasanya merupakan identifikasi unik untuk setiap transaksi. Untuk sementara mengabaikan data customerID juga karna berisi numerik unik, kemungkinan akan dianalisis dari sisi frekuensi
2. Data Quantity dan UnitPrice nilai minimumnya masuk akal namun nilai maksimumnya sepertinya tidak masuk akal karna sangat jauh dari nilai persentil 75% nya, akan di cek lebih lanjut nanti apakah outliers yang masih masuk akal atau tidak
3. Data Quantity dan UnitPrice tidak berdistribusi normal(skewed) dilihat dari nilai mean dan 50% nya yang jauh berbeda
"""

data[kategorik].describe()

"""1. Data StockCode memiliki nilai unik sebanyak 1773, dengan Code yang paling banyak dipakai yaitu 85099B sebanyak 24 kali
2. Data Description memiliki 1807 judul buku(produk yang dijual) dengan judul buku yang paling banyak terjual yaitu 'jumbo bag red retrospot' sebanyak 24 buah. Dari data ini juga terlihat bahwa code 85099B merupakan Stock code untuk produk dengan judul buku 'jumbo bag red retrospot'
3. Terdapat 31 negara asal pelanggan, dengan United kingdom sebagai negara terbanyak yang menjadi asal negara pelanggan yaitu sebanyak 4346 pelanggan. 30 negara lainnya terbagi-bagi untuk 524 pelanggan
4. Setiap unik value StockCode tidak merepresentasikan untuk 1 nama produk karna jumlah unik valuenya berbeda. Kemungkinan satu StockCode untuk Banyak Deskripsi/produk. Akan dianalisis lebih lanjut
"""

# cek data customerID
data.CustomerID.value_counts()

"""Terdapat id unik sebanyak 1932 id dari total transaksi 4870 kali. Customer id dengan frekuensi terbanyak yaitu id 17841 sebanyak 112 kali transaksi.

## Feature Engineering

### Duplicate Handling
"""

data.duplicated().sum()

"""tidak ada data duplicated

### Missing Value Handling
"""

data.isna().sum()

"""Tidak terdapat data null, namun akan mengecek kesesuaian data di beberapa kolom"""

# cek kesesuaian isi data pada kolom description
pd.set_option('display.max_rows', None)
data.Description.value_counts()

"""kesesuaian data sudah benar tidak ada missing value/data yang tidak sesuai"""

# cek kesesuaian isi data pada kolom country
data.Country.value_counts()

"""Terdapat nama country yang tidak sesuai yaitu 'Unspecified' sebanyak 4 buah"""

# persentase data unspecified
(data.Country == 'Unspecified').sum() / len(data.Country) * 100

"""persentase data 'Unspecified' sangat kecil yaitu 0.08% karna dibawah 20% maka saya memutuskan untuk melakukan drop baris untuk data country unspecified tersebut."""

# drop data 'unspecified'
data = data[data.Country != 'Unspecified']

# cek kembali value counts Country
data.Country.value_counts()

"""Data Country sudah bersih dari data yang tidak sesuai

### Outlier Handling
"""

import scipy.stats as stats

def check_plot(data, variable):
    '''
      fungsi mengambil kerangka data (df) dan
      variabel yang diminati sebagai argumen
    '''

    # tentukan ukuran gambar
    plt.figure(figsize=(16, 6))

    # Histogram
    plt.subplot(1, 2, 1)
    sns.histplot(data[variable], bins=30, binwidth=(data[variable].max() - data[variable].min()) / 30, kde=False)
    plt.title('Histogram')
    plt.xlabel(variable)
    plt.ylabel('Frekuensi')

    # Boxplot dengan pengaturan lebar
    plt.subplot(1, 2, 2)
    sns.boxplot(data=data, y=variable, width=0.5)  # Menyesuaikan lebar boxplot
    plt.title('Boxplot')
    plt.ylabel(variable)

    # Tampilkan grafik
    plt.show()

# visualisasikan outlier hanya pada kolom numerik
numerik_kolom = data.select_dtypes(include=['number']).columns
for col in numerik_kolom:
    check_plot(data, col)

"""1. Data InvoiceNo dan CustomerID memiliki distribusi uniform karena datanya merupakan value unik yang angka nya saling berdekatan dan berurut
2. Data Quantity dan Unitprice pada boxplot terdapat banyak dugaan outliers terlihat dari titik titik diluar whiskers
"""

# Cek nilai lowerbound dan upperbound data UnitPrice
Q1 = data['UnitPrice'].quantile(0.25)
Q3 = data['UnitPrice'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

print("Nilai Lowerbound:", lower_bound)
print("Nilai Upperbound:", upper_bound)

# Cek data UnitPrice yang dibawah nilai Lowerbound dan diatas upperbound apakah masuk akal atau tidak
# Mengurutkan kolom UnitPrice dari terkecil hingga terbesar
sorted_unitprice = data.sort_values(by='UnitPrice', ascending=True)

# Menampilkan kolom UnitPrice dan Description
print(sorted_unitprice[['UnitPrice', 'Description']])

"""1. Tidak ada harga barang dibawah lower bound UnitPrice artinya tidak ada outliers dibawah lowerbound.
2. UnitPrice rendah didominasi oleh barang-barang seperti pensil, pulpen, lilin, dan tisu yang masih masuk akal untuk harga sekelas barang-barang tersebut.
3. Terdapat barang-barang dengan harga diatas upperbound (7.50) seperti nesting box, jam dinding, black board, cake stand (harga diatas 10.00), faux fur chocolate throw/selimut bulu (19.95), kitchen cabinet (125.00), dan RUSTIC  SEVENTEEN DRAWER SIDEBOARD sejenis lemari kayu vintage (145.00) harga tersebut masih sangat masuk akal sesuai dengan barang-barangnya. Sehingga menurut saya dugaan outliers yang sebelumnya dilihat dari boxplot itu nilai yang masih sangat masuk akal.
4. Saya tidak akan menghapus data dugaan outliers tersebut.
"""

# Cek nilai lowerbound dan upperbound data Quantity
Q1 = data['Quantity'].quantile(0.25)
Q3 = data['Quantity'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

print("Nilai Lowerbound:", lower_bound)
print("Nilai Upperbound:", upper_bound)

filtered_books = df[df['Quantity'] >=27.0]

# Menampilkan kolom UnitPrice dan Description
filtered_books_sorted = filtered_books[['Quantity', 'Description','UnitPrice']].sort_values(by='Quantity', ascending=False)
print(filtered_books_sorted)

"""1. Dari data dugaan outliers pada data Quantity, terdapat quantity pembelian sebanyak 992 untuk barang WHITE HANGING HEART T-LIGHT HOLDER ini sangat memungkinkan terjadi. Jumlah besar ini bisa mewakili pembelian grosir (untuk dijual kembali) serupa dengan dugaan barang-barang(description) lainnya yang dibeli dalam quantity yang besar.
2. Barang-barang yang dibeli dengan quantity besar memiliki harga yang cenderung rendah(<4.00), jadi sangat memungkinkan untuk dibeli dalam jumlah banyak. Kecuali ada 3 barang yaitu WOODEN ADVENT CALENDAR RED(12.75), CHEST OF DRAWERS GINGHAM HEART(16.95),  dan REGENCY CAKESTAND 3 TIER (10.95) yang quantity nya berkisar 28-39. Barang-barang ini juga sangat mungkin dan masuk akal dibeli dalam jumlah seperti itu, bisa jadi mewakili para kontraktor perumahan, store furniture, toko kue dengan banyak cabang yang membutuhkan cakestand, atau para distributor barang-barang tersebut.
3. Dugaan outliers pada data quantity masih masuk akal/relevan sehingga saya memutuskan untuk mempertahankan data tersebut.

### Transformasi Data

Transformasi data yang digunakan adalah Log transformation karena data yang kita miliki memiliki rentang nilai yang sangat besar atau data dengan distribusi yang tidak normal. Tujuan penggunaan log transformation ini untuk membantu memperbaiki representasi visual datanya saja.
"""

# handling outliers UnitPrice dengan log transformation
# Mengurangi dampak nilai ekstrem pada visualisasi
data['UnitPrice_Log'] = np.log1p(data['UnitPrice'])
# Histogram sebelum transformasi
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
sns.histplot(data['UnitPrice'], bins=30, kde=False, color='blue')
plt.title('Distribusi UnitPrice (Asli)')
plt.xlabel('UnitPrice')

# Histogram setelah log transformasi
plt.subplot(1, 2, 2)
sns.histplot(data['UnitPrice_Log'], bins=30, kde=False, color='orange')
plt.title('Distribusi UnitPrice (Setelah Log Transformasi)')
plt.xlabel('UnitPrice (Log)')
plt.tight_layout()
plt.show()

# handling outliers Quantity dengan log transformation
# Mengurangi dampak nilai ekstrem pada visualisasi
data['Quantity_Log'] = np.log1p(data['Quantity'])
# Histogram sebelum transformasi
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
sns.histplot(data['Quantity'], bins=30, kde=False, color='blue')
plt.title('Distribusi Quantity (Asli)')
plt.xlabel('Quantity')

# Histogram setelah log transformasi
plt.subplot(1, 2, 2)
sns.histplot(data['Quantity_Log'], bins=30, kde=False, color='orange')
plt.title('Distribusi Quantity (Setelah Log Transformasi)')
plt.xlabel('Quantity (Log)')
plt.tight_layout()
plt.show()

"""setelah dilakukan transformasi data Nilai besar dikompresi sehingga jarak antar nilai menjadi lebih kecil.<br>
Distribusi data berubah, untuk mengurangi pengaruh nilai ekstrem.

# 2. Setelah melakukan feature engineering, Ikuti anjuran berikut :
- Buat 5 pertanyaan analisa
- jawab dengan pendekatan metode data manipulation (sorting, filtering, group by, pivot, melt, crosstab, working with datetime, dsb (sesuaikan dengan keperluan anda
- Buatlah visualisasi grafik supaya mempermudah dalam ekstraksi insight setelah menjawab menggunakan metode data manipulation diatas
- Tulis insight anda

`poin` :
- insight / observation : **10 poin (1 pertanyaan 2 poin)**
- pertanyaan analisis dan jawaban metode data manipulation : **30 poin (1 pertanyaan 7 poin)**
- data visualisasi : **30 poin (1 visualisasi dari 1 pertanyaan 7 poin)**

5 Pertanyaan analisa:
1. Produk apa yang paling banyak dibeli oleh pelanggan dari United Kingdom? (10 produk paling banyak dibeli)
2. Kapan waktu yang paling banyak terjadi transaksi?
3. StockCode mana saja yang merepresentasikan lebih dari 1 produk (description)?
4. Bagaimana distribusi invoice setiap bulan?
5. Bagaimana Jumlah Pelanggan unik untuk setiap negara?
6. Bagaimana total penjualan (total price) per bulan di tahun 2011 di setiap negara?

### Filtering

1. Produk apa yang paling banyak dibeli oleh pelanggan dari United Kingdom? (10 produk paling banyak dibeli)
"""

data_filtered = data[data['Country'] == 'United Kingdom']
data_filtered.head()

data_filtered.Description.nunique()

# hitung jumlah quantity per description dan diurutkan dari besar ke kecil
desc_counts = data_filtered[['Description','Quantity']].sort_values(by=['Quantity'], ascending=False).reset_index().head(10)
desc_counts

# Visualisasi dalam bentuk bar chart
plt.figure(figsize=(12, 6))
ax = sns.barplot(data=desc_counts, x='Description', y='Quantity', color='purple')

# tambahkan label angka di atas bar
for i in ax.containers:
    ax.bar_label(i, fmt='%d')

plt.title('10 Produk Paling Banyak dibeli Pelanggan dari United Kingdom', fontsize=16)
plt.xlabel('Description', fontsize=12)
plt.ylabel('Quantity', fontsize=12)
plt.xticks(rotation=90)

plt.show()

"""Dari total 1805 jenis barang yang ada di e-commerce, 1728 jenis barang (description) pernah dibeli oleh pelanggan dari United Kingdom. Berikut 10 barang yang paling banyak dibeli oleh pelanggan dari United Kingdom:
1. WHITE HANGING HEART T-LIGHT HOLDER	(992)
2. CREAM HEART CARD HOLDER	(972)
3. WRAP, BILLBOARD FONTS DESIGN	(800)
4. MIRROR MOSAIC T-LIGHT HOLDER	(720)
5. SWEETHEART BIRD HOUSE	(620)
6. ASSORTED COLOURS SILK FAN	(600)
7. BLACK RECORD COVER FRAME	(480)
8. PAPER CHAIN KIT EMPIRE	(320)
9. HOT WATER BOTTLE I AM SO POORLY	(312)
10. JUMBO BAG OWLS	(300)

### Working With Datetime

2. Kapan waktu yang paling banyak terjadi transaksi?
"""

# ubah type data menjadi datetime
data.InvoiceDate = pd.to_datetime(data.InvoiceDate)
data.info()

# Menambahkan kolom encoding_time berdasarkan jam
data['encoding_time'] = pd.cut(data['InvoiceDate'].dt.hour,
                               bins=[0, 10, 15, 19, 24],
                               labels=['Pagi', 'Siang', 'Sore', 'Malam'])
data.head()

# melihat jumlah setiap value yang sudah di encoding
waktu_transaksi = data.encoding_time.value_counts()
waktu_transaksi

# visualisasi pie chart
fig, ax = plt.subplots()
explode = (0.1, 0, 0.1, 0.2)
ax.pie(waktu_transaksi.values, labels=waktu_transaksi.index,
      startangle=90, autopct='%1.1f%%', explode=explode)
plt.show()

"""1. Waktu yang paling banyak terjadi transaksi adalah pada siang hari diantara jam 11.00-15.00 sebanyak 72.1% dari total keseluruhan transaksi. Sedangkan waktu yang paling sedikit terjadi transaksi adalah malam hari hanya sekitar 0.2% diantara jam 19.00-24.00
2. Dari informasi ini, bisa melihat bagaimana perilaku konsumen. Bisa jadi peningkatan transaksi di siang hari dikarenakan siang hari merupakan puncak aktivitas manusia sehingga orang-orang banyak mengingat barang-barang yang dibutuhkan dan melakukan transaksi, bisa juga karena rehat sejenak dari suntuknya pekerjaan kemudian mencari selingan hiburan lewat aplikasi ecommerce dan berujung transaksi. Pada malam hari, orang-orang cenderung menggunakan waktu untuk istirahat dan berkumpul bersama keluarga sehingga intensitas untuk membuka ecommerce sedikit.
3. Untuk meningkatkan transaksi di waktu-waktu yang lain mungkin bisa menggunakan promo prime hour, misal di jam 7.00 terdapat cashback 20% untuk setiap transaksi yang dilakukan pada jam tersebut sehingga nantinya bisa meningkatkan transaksi dan penjualan di waktu pagi hari.
4. Dari informasi ini juga ada indikasi bahwa produk-produk yang banyak dibeli pelanggan United Kingdom (pertanyaan no 1), terjual di siang hari.

### Group by

3. StockCode mana saja yang merepresentasikan lebih dari 1 barang(description)?
"""

stockcode_more_than_1_items = data.groupby('StockCode')['Description'].nunique()

# Menyaring StockCode yang memiliki lebih dari 1 barang unik(description)
stockcode_more_than_1_items = stockcode_more_than_1_items[stockcode_more_than_1_items > 1]
stockcode_more_than_1_items.sort_values(ascending=False)

# Melihat nama-nama produk yang unik untuk setiap StockCode
stockcode_product_names = data.groupby('StockCode')['Description'].unique()

# Menampilkan StockCode yang memiliki lebih dari 1 barang(description), dan nama barang terkait
for stockcode in stockcode_more_than_1_items.index:
    print(f"StockCode: {stockcode} - Produk: {', '.join(stockcode_product_names[stockcode])}")

stockcode_counts = stockcode_more_than_1_items.value_counts().sort_index()
stockcode_counts

# visualisasi bar chart
lt.figure(figsize=(10, 6))
plt.bar(stockcode_counts.index, stockcode_counts.values, color='skyblue')
plt.title('Jumlah StockCode berdasarkan Jumlah Barang Unik', fontsize=14)
plt.xlabel('Jumlah Barang Unik', fontsize=12)
plt.ylabel('Jumlah', fontsize=12)
plt.xticks(stockcode_counts.index)  # Menampilkan setiap kategori jumlah barang unik pada sumbu X
plt.show()

"""1. Terdapat 32 stockCode yang merepresentasikan lebih dari 1 barang, 30 stockCode merepresentasikan 2 barang dan 2 lainnya merepresentasikan 3 barang.
2. kebanyak stockCode tersebut sebenarnya merujuk pada barang yang sama tapi descriptionnya ada perbedaan sedikit seperti penggunaan tanda '+' dan 'and', ada perbedaan/kelebihan spasi, penggunaan huruf vokal yang berbeda seperti 'i' dan'y', penggunaan jamak dan tunggal seperti 'leaf' dan 'leaves'.
3. Namun ada juga beberapa stockCode yang sepertinya tidak merujuk pada 2 atau 3 fisik barang yang sama, seperti StockCode: 22999 - Produk: TRAVEL CARD WALLET VINTAGE LEAF, TRAVEL CARD WALLET RETRO PETALS. StockCode 22999 apakah merujuk pada fisik yang benar-benar sama atau malah berbeda model. contoh lainnya StockCode: 22197 - Produk: SMALL POPCORN HOLDER, POPCORN HOLDER, stockcode tersebut apakah merujuk pada ukuran yang berbeda (small dan tidak small) atau fisik ukuran barangnya sama. Ini mungkin harus dikonfirmasi ke pembuat stockcode atau orang di warehouse atau manajemen inventaris
4. Apabila stockcode tidak benar-benar merujuk pada description 2 atau 3 barang yang sama persis, maka seharusnya dibuatkan stockcode baru sehingga StockCode seharusnya mewakili satu jenis barang saja. Apabila tidak dilakukan, bisa membingungkan saat melakukan analisis inventaris atau saat tracking penjualan dan juga stok barang bisa tumpang tindih atau sulit untuk dipantau dengan akurat.

4. Bagaimana distribusi invoice per bulan (tahun 2011)?
"""

# memisahkan tanggal, bulan, dan waktu ke kolom yang berbeda-beda
data['Date_Invoice'] = data.InvoiceDate.dt.date
data['Year_Invoice'] = data.InvoiceDate.dt.year
data['Month_Invoice'] = data.InvoiceDate.dt.month
pd.set_option('display.max_column', None)

# Filter data untuk tahun 2011
data_2011 = data[data['Year_Invoice'] == 2011]

# Menghitung jumlah invoice per bulan
invoice_per_month = data_2011.groupby('Month_Invoice').size()

# visualisasi bar plot
fig, ax = plt.subplots(figsize=(10, 6))
invoice_per_month.plot(kind='bar', color='skyblue', ax=ax)

# Menambahkan keterangan jumlah di atas setiap bar
ax.bar_label(ax.containers[0], label_type='edge', padding=5)

# Menambahkan judul dan label sumbu
plt.title('Distribusi Invoice Berdasarkan Bulan (Tahun 2011)')
plt.xlabel('Bulan')
plt.ylabel('Jumlah Invoice')

# Memutar label pada sumbu x a
plt.xticks(rotation=45)

plt.tight_layout()
# Menampilkan grafik
plt.show()

"""1. Distribusi invoice tahun 2011 paling banyak pada bulan 11 yaitu November sebanyak 824 invoice dan paling sedikit pada bulan Desember.
2. Distribusi invoice paling anjlok terjadi dari bulan november ke desember yang berarti kegiatan transaksi di ecommerce turun drastis.
3. Bulan januari ke Februari dan bulan Juli ke Agustus mengalami kenaikan  sangat sedikit sekali yaitu tidak lebih dari 13 invoice.
4. Banyaknya jumlah invoice ini tidak merepresentasikan Total_Price atau total penjualan setiap bulannya karena bisa saja invoice nya banyak namun secara total price di setiap invoicenya kecil.

### Crosstab

5. Bagaimana Jumlah Pelanggan unik untuk setiap negara?
"""

# Menggunakan crosstab untuk menghitung jumlah pelanggan unik per negara
unique_customers_per_country = pd.crosstab(df['Country'], df['CustomerID'])

# Menjumlahkan jumlah pelanggan unik di setiap negara
unique_customers_per_country = unique_customers_per_country.gt(0).sum(axis=1).sort_values(ascending=False)

# Menampilkan hasil
print(unique_customers_per_country)

# visualisasi bar plot
fig, ax = plt.subplots(figsize=(10, 6))
unique_customers_per_country.plot(kind='bar', color='skyblue', figsize=(10, 6))

# Menambahkan keterangan jumlah di atas setiap bar
ax.bar_label(ax.containers[0], label_type='edge', padding=5)

plt.title('Jumlah Pelanggan Unik Berdasarkan Country')
plt.xlabel('Country')
plt.ylabel('Jumlah Pelanggan Unik(CustomerID)')
plt.tight_layout()

# Menampilkan grafik
plt.show()

"""1. Pelanggan unik paling banyak diduduki oleh United kingdom, posisi ke-2 Germany, posisi ke-3 France, posisi ke-4 spain dan switzerland, posisi ke-5 Belgium, dan posisi ke-6 Portugal.
2. Terdapat 3 negara yang memiliki pelanggan unik 5, 6 negara yang memiliki pelanggan unik 4, 4 negara dengan pelanggan unik 3, 2 negara dengan pelanggan unik 2, dan 9 negara dengan pelanggan unik hanya 1.
3. Negara-negara yang memiliki pelanggan unik sedikit bisa dijadikan prospek kedepannya, mungkin dengan ads/iklan yang menjangkau wilayah-wilayah tersebut.

### Pivot

6. Bagaimana total penjualan (total price) per bulan di tahun 2011 di setiap negara?
"""

pd.set_option('display.max_column', None)

# Membuat pivot table untuk total harga per bulan di setiap negara
tabel_pivot = pd.pivot_table(data_2011, values='Total_Price', index='Month_Invoice', columns='Country', aggfunc='sum', fill_value=0)

tabel_pivot

"""Ada beberapa visualisasi untuk menjelaskan insight dari tabel pivot diatas."""

# Visualisasi
plt.figure(figsize=(12, 6))

# Menggunakan loop untuk menggambar grafik untuk setiap Country
for country in tabel_pivot.columns:
    plt.plot(tabel_pivot.index, tabel_pivot[country], label=country, marker='o')

# Menambahkan label dan judul
plt.title('Total Penjualan Per Bulan di Setiap Negara untuk Setiap Bulan (Tahun 2011)')
plt.xlabel('Bulan')
plt.ylabel('Total Penjualan (Total Price)')
plt.xticks(tabel_pivot.index, rotation=45)
plt.legend(title='Country')

# Menampilkan plot
plt.tight_layout()
plt.show()

"""1. Secara keseluruhan total penjualan per bulan paling banyak adalah dari negara United Kingdom, dilihat dari garis yang selalu berada diatas dibanding garis negara lain, negara-negara lainnya jauh dibawah UK,
2. Dari grafik ini terlihat ada negara-negara yang tidak memiliki total penjualan di bulan-bulan tertentu artinya negara-negara tersebut tidak setiap bulan ada riwayat transaksi.

"""

# Melihat negara yang memiliki transaksi di setiap bulan
# Negara yang memiliki transaksi di setiap bulan harus memiliki nilai > 0 di setiap bulan
negara_komplit = tabel_pivot.columns[tabel_pivot.gt(0).all(axis=0)]

# Memisahkan tabel pivot dengan negara yang memiliki transaksi di setiap bulan
tabel_pivot_komplit = tabel_pivot[negara_komplit]

# Menampilkan pivot tabel untuk negara yang memiliki transaksi di setiap bulan
print(tabel_pivot_komplit)

# visualisasi
plt.figure(figsize=(12, 6))

# Menggunakan loop untuk menggambar grafik untuk setiap negara
for country in tabel_pivot_komplit.columns:
    plt.plot(tabel_pivot_komplit.index, tabel_pivot_komplit[country], label=negara, marker='o')

# Menambahkan label dan judul
plt.title('Total Penjualan Per Bulan di Setiap Negara yang Memiliki Transaksi di Setiap Bulan (Tahun 2011)')
plt.xlabel('Bulan')
plt.ylabel('Total Penjualan (Total Price)')
plt.xticks(tabel_pivot_komplit.index, rotation=45)
plt.legend(title='Country')

# Menampilkan plot
plt.tight_layout()
plt.show()

"""1. Terdapat 4 negara yang setiap bulannya melakukan transaksi yaitu United Kingdom, France, Germany, EIRE.
2. Kalau kita hubungan dengan jumlah pelanggan uniknya (pertanyaan no.5), maka UK, France, dan Germany sama-sama menduduki peringkat 3 jumlah pelanggan terbanyak dan sama menduduki 3 negara dengan total penjualan terbanyak (negara yang konsisten ada transaksi setiap bulannya) artinya cukup linier antara jumlah pelanggan unik dengan total penjualannya. Namun berbeda dengan EIRE, EIRE hanya memiliki 3 pelanggan namun bisa konsisten melakukan transaksi setiap bulannya, namun tidak membuktikan bahwa EIRE merupakan negara ke-4 dengan total penjualan terbanyak dari semua negara, karena grafik ini hanya menunjukkan negara yang konsisten melakukan transaksi setiap bulannya, bisa jadi negara yang tidak konsisten setiap bulan punya kedudukan total penjualan yang lebih tinggi dari EIRE.

# 3. Lakukan analisa multivariate pada kolom numerikal berupa :
- Correlation Heatmap + insight / observation **(10 poin)**
"""

# Menghitung korelasi antar kolom numerikal
correlation_matrix = data[['Quantity', 'UnitPrice', 'Total_Price']].corr()

# Menampilkan korelasi dengan heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f', cbar=True)
plt.title('Matriks Korelasi Variabel Numerikal')
plt.show()

"""1. Total price dan Quantity memiliki korelasi positif yang tinggi satu sama lain. Banyaknya quantity yang dibeli pasti memengaruhi besarnya total price.
2. Unit Price dan Quantity memiliki korelasi negatif yang rendah/lemah (bertanda negatif dan nilai mendekati 0), ini berarti bahwa ketika harga per unit naik, jumlah barang yang terjual cenderung turun sedikit, atau sebaliknya, tetapi perubahan ini tidak begitu signifikan dan tidak terlalu kuat.
3. Heatmap korelasi dilakukan untuk data numerikal saja.
4. Pada dataset tertentu heatmap korelasi bisa dilakukan untuk data kategorikal, namun pada dataset ecommerce.csv ini data kategorikalnya tidak memungkinkan untuk di encoding karena nilai uniknya begitu banyak (InvoiceNo, CustomerID, Description, InvoiceDate, Country, StockCode)
"""